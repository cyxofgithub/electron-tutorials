# 进程间通信(Inter-Process Communication)

进程间通信（IPC）是在 Electron 中构建功能丰富的桌面应用程序的关键部分。由于在 Electron 的进程模型中，主进程和渲染器进程的职责不同，因此 IPC 是执行许多常见任务的唯一方式，例如从用户界面调用本地 API 或从本地菜单触发网页内容更改。

## IPC 通道(IPC channels)

在 Electron 中，进程通过开发者定义的 "通道(channels) "与 ipcMain 和 ipcRenderer 模块传递消息。这些通道是任意的（你可以给它们起任何名字），并且是双向的（你可以在两个模块中使用相同的通道名）。

在本指南中，我们将通过具体示例介绍一些基本的 IPC 模式，供您在编写应用程序代码时参考。

## 模式 1： 渲染器到主线程（单向通信）Renderer to main (one-way)

要从渲染器进程向主进程发送单向 IPC 消息，可以使用 ipcRenderer.send API 发送消息，然后由 ipcMain.on API 接收。

您通常使用这种模式从网页内容中调用主进程 API。我们将通过创建一个能以编程方式更改窗口标题的简单应用程序来演示这种模式。

在这个演示中，你需要在主进程、渲染器进程和预加载脚本中添加代码。完整的代码如下，但我们会在下面的章节中逐一解释每个文件。

### 1. 使用 ipcMain.on 监听事件

在主进程中，使用 ipcMain.on API 在 set-title 通道(channel)上设置 IPC 监听器：

```javascript
// main.js
const { app, BrowserWindow, ipcMain } = require("electron");
const path = require("node:path");

// ...

function handleSetTitle(event, title) {
    const webContents = event.sender;
    const win = BrowserWindow.fromWebContents(webContents);
    win.setTitle(title);
}

function createWindow() {
    const mainWindow = new BrowserWindow({
        webPreferences: {
            preload: path.join(__dirname, "preload.js"),
        },
    });
    mainWindow.loadFile("index.html");
}

app.whenReady().then(() => {
    ipcMain.on("set-title", handleSetTitle);
    createWindow();
});
// ...
```

上述 handleSetTitle 回调函数有两个参数：一个 IpcMainEvent 结构和一个标题字符串。每当有消息通过 set-title 频道时，该函数就会找到与消息发送者相连的 BrowserWindow 实例，并对其使用 win.setTitle API。

### 2. 通过预加载公开 ipcRenderer.send

要向上面创建的监听器发送消息，可以使用 ipcRenderer.send API。默认情况下，渲染器进程没有 Node.js 或 Electron 模块访问权限。作为应用程序开发人员，你需要选择使用 contextBridge API 从预载脚本中公开哪些 API。

在预加载脚本中，添加以下代码，这将向呈现器进程公开一个全局 window.electronAPI 变量。

```javascript
// preload.js
const { contextBridge, ipcRenderer } = require("electron");

contextBridge.exposeInMainWorld("electronAPI", {
    setTitle: (title) => ipcRenderer.send("set-title", title),
});
```

此时，您就可以在渲染器进程中使用 window.electronAPI.setTitle() 函数了。

> 安全警告
> 出于安全考虑，我们不会直接公开整个 ipcRenderer.send API。确保尽可能限制渲染器对 Electron API 的访问。

### 3、构建渲染器流程用户界面

在 BrowserWindow 已加载的 HTML 文件中，添加一个由文本输入和按钮组成的基本用户界面：

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP -->
        <meta
            http-equiv="Content-Security-Policy"
            content="default-src 'self'; script-src 'self'"
        />
        <title>Hello World!</title>
    </head>
    <body>
        Title: <input id="title" />
        <button id="btn" type="button">Set</button>
        <script src="./renderer.js"></script>
    </body>
</html>
```

为了使这些元素具有交互性，我们将在导入的 renderer.js 文件中添加几行代码，利用预加载脚本中的 window.electronAPI 功能：

```javascript
const setButton = document.getElementById("btn");
const titleInput = document.getElementById("title");
setButton.addEventListener("click", () => {
    const title = titleInput.value;
    window.electronAPI.setTitle(title);
});
```

至此，您的演示程序应该可以完全正常运行了。试试使用输入框，看看 BrowserWindow 标题会发生什么变化！

## 模式 2：渲染器到主线程（双向通信）Renderer to main (two-way)

...待续
