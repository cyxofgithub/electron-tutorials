# 消息端口 MessagePorts
MessagePorts 是一种允许在不同上下文之间传递消息的网络功能。它就像 window.postMessage，只不过是在不同的通道上。本文档旨在描述 Electron 如何扩展通道消息模型，并举例说明如何在应用程序中使用 MessagePorts。
下面是一个非常简单的例子，说明什么是 MessagePort 及其工作原理：
```javascript
// renderer.js
// MessagePorts are created in pairs. A connected pair of message ports is
// called a channel.
// 消息端口成对创建。一对相连的消息端口是被称作通道
const channel = new MessageChannel()

// The only difference between port1 and port2 is in how you use them. Messages
// sent to port1 will be received by port2 and vice-versa.
// 端口 1 和端口 2 的唯一区别在于如何使用它们。信息发送到端口 1 的信息将被端口 2 接收，反之亦然。
const port1 = channel.port1
const port2 = channel.port2

// It's OK to send a message on the channel before the other end has registered
// a listener. Messages will be queued until a listener is registered.
// 在另一端注册一个监听器之前，可以在信道上发送信息。信息将被排在队列中，直到有监听者注册为止。
port2.postMessage({ answer: 42 })

// Here we send the other end of the channel, port1, to the main process. It's
// also possible to send MessagePorts to other frames, or to Web Workers, etc.
// 在这里，我们将通道的另一端端口 1 发送给主进程。也可能将 MessagePorts 发送到其他框架（frames）或 Web Worker 等
ipcRenderer.postMessage('port', null, [port1])
```

```javascript
// main.js
// In the main process, we receive the port.
// 在主线程中，我们将接受到这个端口
ipcMain.on('port', (event) => {
  // When we receive a MessagePort in the main process, it becomes a
  // MessagePortMain.
  // 当我们在主线程接受到 MessagePort，它会变成一个消息端口主站
  const port = event.ports[0]

  // MessagePortMain uses the Node.js-style events API, rather than the
  // web-style events API. So .on('message', ...) instead of .onmessage = ...
  // 消息端口主站使用的Node.js风格的事件API，而不是web风格的事件API。例如。。。
  port.on('message', (event) => {
    // data is { answer: 42 }
    const data = event.data
  })

  // MessagePortMain queues messages until the .start() method has been called.
  // 消息主战会让消息排队等待直到 .start() 方法是被调用
  port.start()
})
```
[Channel Messaging API](https://developer.mozilla.org/en-US/docs/Web/API/Channel_Messaging_API) 文档是了解 MessagePorts 工作原理的绝佳途径。

## 主进程的信息端口
...待续